## 对象的封装原则(思维)

- 单一原则， 每个对象只做与自己有关的事情， 不要想着跨域。
- 高阶函数，高阶对象。
- 因为作用域的原因， 对象应该封装在 匿名函数里面 function(){return claa}; `鲁棒原则`
- 基于`鲁棒原则` 每个对象单独使用一个 js 文件封装出去。
- js 的文件名就用其内部封装的 class 对象名来表达则可。
-

## 异常捕获

> try throw(抛) catch finally 最终(finally (return 也最终都会执行))
> raise throw(抛)

```javascript
try {
  // 主要代码块
  console.log(a);
  // throw(ReferenceError);
} catch (error) {
  // try 出现 bug 将停止执行，跳到catch
  // error(参数变量) 异常类型
  console.error(error, error.message);
} finally {
} // finally (try里有 return 也会执行)最终都会执行。
// return 应该放在 finally 里。 因为 无论在 try 和 catch 里的return都会 被覆盖。
```

- 捕捉和处理异常
- 用来处理闭包

```javascript
function test() {
  var num = 1;
  return function() {
    try {
      throw "lailai";
      return num;
    } catch (error) {
      // 传进来的 error 是一个 对象。
      console.log(typeof error, error); //string lailai
      console.error(error);
    } finally {
      num = undefined; // 此时num 以经拿到了， 但是此放回的函数只能 调用一次。
    }
  };
}
let te = test();
console.log(te(), "ff");
console.log(te(), "aa");
```

## 正则表达式 regular expression

[github 别人的用法](https://github.com/smileyby/zhengze#js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%80%BB%E7%BB%93)

new RegExp();  中的 '\' 与 /'\'/ 是不同的。 


- 按位对应。

- 特殊字符范围: `\x21-\x2f\x3a-\x40\x5b-\x60\x7B-\x7F`;
- 中文字符范围 : `\u4e00-\u9fa5`;

- `\d`: `digit` 数字 \D 非数字
- `\w`: `word` 单词 (字母，数字，下划线) \W 非单词
- `\r`: `return` 回车
- `\n`： `newline` 换行
- `\s`: `space` 空间，空白
- `\t`: `table` 制表符
- `\v`: `vertical` 垂直
- `\b` : Boundaries, 单词的边界， 就是 `单词以空格之间`
  - 什么可以当做一个单词呢？  word , 一个汉字， 一个数字， 都可以被认为是一个单词。 
- `\B`  :   非单词边界。 
- `\0` : `null`

- 模式 (全局 || 一个)
  ( 元表示单一字符。 )
- 元字符 : `.` `[abcd],[a-z] (代表一个字符)` `\d | \D` `\w` `^ (首位， 非)`
- 限定符 : (限定长度， 模式)
  - `[a]{n} a连续n次` `一定要够n 个`
  - `{n,} 至少n次`
  - `{n,m}` 闭合的范围[] ，n > .<M 都可以。
  - `* {0,}` `+ {1,}` `? {0,1}` `*？贪婪` `+? 非贪婪`
  - `^ 开头`
  - `$ 结尾`
  - `^$ 严格一点`
  - `|` `或`
- `() 优先， 分组`
  - 捕获型 () , 只有() 才参与捕获, 分组值 由 `$1, $2...` 获取
    - `\1` `()\1重复一次(配合 + 使用) 括号内的匹配` `(\d)\1+` `'$1'`重复多次
    - `\2` `(1)(2)\2`
    - () 自动命名组 用 `$digit` 来取
    - (?'name') `自己命名组名字为 name`
  - 非捕获型 (?:)
  - 正向前瞻型 x(?=exp) Lookahead assertion:
    - 断言相当于判断。 本应 x(?=..) x(忽略) (?=..) 就只是判断。 断言里面的所有都是不参与匹配的， exec 是个实行分组的方法， 例外
  - 反向前瞻型 (?!exp)x Negative lookahead assertion
  - 后瞻断言 (?<=) Lookbehind assertion
  - 反向后瞻断言 (?<!) Negative lookbehind assertion
    > 我们使用的比较多的都是()捕获型分组，只有这种分组才会暂存匹配到的串, 其他的断言只是辅助断言, 只是用于判断。

* ## 断言 ： Assertions ()
* 边界 : Boundaries
* 字符类型 : Character Classes
* 组合范围
* 量词
* Unicode 属性转义

#### 断言万能公式

- (?=.\*...) ...(这三个点 要啥给啥)

### 声明方式

```javascript
// RegExp(param1, param2) ; p1正则表达式, p2 匹配规则
//new RegExp(pattern, attributes); // pattern (str),
// attributes  "g" global、"i" ignoreCase  和 "m" multiply | multiple，分别用于指定全局匹配、区分大小写的匹配和多行匹配。
var regex = new RegExp('ab+c'); ==> var regex = /ab+c/;
```

### 方法

- `test` `exec` `match` `matchAll` `search` `replace` `split`
- `regex.test(str)`; // 验证 true false 。str `要比较的的str` `是否符合`
- `regex.exec(str)` `execute 执行`; //
  - exec 用于循环匹配，和 分组匹配 
  - return [ '0':'', '1' : group1, '2' : group2 ]
    - 0 是分组之外匹配到的。   1 是第一个()括号匹配到的，  2 第二个括号匹配到的。 
- `match` 在全局模式下，体现不出来分组的功能。 非全局的情况下可以体现出来分组的功能。
  - 全局模式下就是多次匹配，  先要多次匹配，又要有分组就可以用 exec 循环匹配函数。  

```js
/1(2)(3).*/g.exec( '123456789' ) ; 
/* 
0: "123456789"  // 0 是 匹配到的
1: "2"          // 1 是第一个括号的分组
2: "3"          // 2 是第二个括号的分组
 */

'123456789'.match( /1(2)(3).*/g )；
/* 
0: "123456789"    // 全局下  match 没有体现数分组的功能 , 而且分组的和不分组的都是公用了一个匹配
length: 1
 */
'123456789'.match( /1(2)(3).*/ ) // 当非全局下， match 可以体现出 分组的功能。 
/* 
0: "123456789"
1: "2"
2: "3"
groups: undefined
 */

'123456789'.replace( /(2)*/g, ',' );
/* 
  ",1,,3,4,5,6,7,8,9,"  ;    // 
 */
'123456789'.split( /(?=)/g ) == '123456789'.split( '' )
/* 
    ["1", "2", "3", "4", "5", "6", "7", "8", "9"]
 */

```
### 我的误区
> 我认为字符与字符之间的相连是不能匹配到的， 实则是可以匹配到的   ''
> 就是 空字符( 不是空白字符 ) 的匹配 '' 是可以匹配的。  




## 电话号码

`^(\+86)?13\d{9}$`

## 邮箱

^\d{5,11}@qq.com\$|

-

^[a-zA-Z0-9]+@[a-zA-Z0-9]+(\.[a-zA-Z0-9]+)+\$

## 字符串 API

- `charAt() == [index]` `concat()` `indexOf()`
- `charAt(index)=> 字符值`
- `+` 每次+ 完都会在内存里遗留上一次+ 完的字符串
- `str.concat(strli)` 效率高点 字符串相加
- `str.indexOf(searchString,position) => n(第一个出现的位置) 或 -1`
- `str.lastIndexOf() 最后出现的位置`
- `str.match(str1)`
- `str.repace()`
- `search()`
- `slice(start,end)` `substr(start,length)` `substring(start, end) 不包含end`
- `trim()` `trimStart()` `trimEnd()`

## 文章

[nodejs](https://github.com/jimuyouyou/node-interview-questions)

## for in of

for in

> 以任意顺序遍历一个对象自有的、(继承的)、可枚举的、非 Symbol 的属性。对于每个不同的属性，语句都会被执行。
> for in 一般是遍历 自身的属性的， 当时有时也要 用 `obj.hasOwnProperty(property)` 判断是否是自身的属性。
> for of
> 在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句

```javascript
function test() {
  console.log("a");
}
test.prototype = Object.prototype;
test.prototype.a = function() {};
console.log(test.prototype);
for (var a in test.prototype) {
  console.log(a);
}
```

## new 的坑。

1） 优先级
2） 构造函数里面的 return obj ; 返回一个对象会 覆盖原来的 (改变 this 的)对象

```javascript
var obj = { grad: "ha" };
function func1(obj) {
  this.name = "na";
  this.age = 20;
  return obj;
}
var f1 = new func1(obj);
console.log(f1); //=>  obj
```

## Array

- arr.concat(arr1,arr2，arr3); // 拼接数组，成一维数组
- arr.join([separator]); // separator 分割符 =》 字符串
- arr.shift(); //从数组中删除第一个元素，并返回该元素的值。 更改原函数
  - return 当一个对象调用该方法时，返回其 length 属性值。
- arr.unshift(element1...); // 首位添加， => length
- arr.push(elemts); // 尾部追加。 => length
- arr.slice(begin[,end]); // return newArray
- arr.splice(start[,deleteCount],[,item,..]); //用 item 替换多少个 deleteCount
- arr.pop(); 弹出， 修改原函数

## delete

> delete 操作符与直接释放内存无关。内存管理 通过断开引用来间接完成的
> 操作符用于删除对象的某个属性；如果没有指向这个属性的引用，那它最终会被释放。
> 只是个值给删除了， 数组长度没变
> return true; 基本是 放回 true, 只有在严格模式下 c 才有可能返回 false
> 除了在全局作用域中的函数不能被删除，在对象(object)中的函数是能够用 delete 操作删除的。

- 可以直接 删除 对象属性。
- delete expression

```javascript
// 模拟 pop
Array.prototype.mypop = function() {
  var end = this[this.length - 1];
  delete this[this.length - 1];
  this.length = this.length - 1;
  return end;
};
```

## length -1 ; 原来的值还会在 内存中

## Date 对象

- `new Date();` // Mon Sep 23 2019 12:04:23 GMT+0800 (中国标准时间)
- `new Date(value);` // (2000-09-05 00:21:00:000)
- `new Date(dateString);` // (1990-09-05 00:21:00:000)
- `new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]]);`

- `year` `month` `day` `hour` `minute` `seconds`
- return 的 格林威治日期格式

- 2019-09-23 11:59:00;

方法 `getFullYear` `getdate(月份的 第几天)` `getday 星期第几天` `getHours()` `getMinutes()` `getMillisecondes() 0-999`

- new Date().getFullYear() ; // number
- new Date().getMonth(); // 老外是 从 0 (12)开始计算的。
- new Date().getdate(); // 月第几天
- new Date().getday(); // 星期 n 天

### 时间戳

> 时间戳:是指格林威治时间 1970 年 01 月 01 日 00 时 00 分 00 秒(北京时间 1970 年 01 月 01 日 08 时 00 分 00 秒)起至现在的总秒数。

- 1 秒 == 1000 毫秒
- 1 秒=1000 毫秒(ms), 1 毫秒=1／1000 秒(s)；
- 1 秒=1000000 微秒(μs), 1 微秒=1／1000000 秒(s)；
- 1 秒=1000000000 纳秒(ns),1 纳秒=1／1000000000 秒(s)；
- 1 秒=1000000000000 皮秒 1 皮秒==1/1000000000000 秒。

固定时间内-删除内存(过期内容)

## 类型检测

- 检测数组 Array.isArray( value ); // true， false
- typeOf
- instanceof
- Object.prototype.toString.call()
  - Object.prototype.toString.call(f).includes('Number')
  - `Object.protoptype.toString 可以获取类型的字符串值。`
  - `call 改变 toString 的this指向。`
  - Number.prototype.toString 已经覆盖了 Object.prototype.toString 的方法。
  - 基本上， 每个类型 都已经重写了 toString 方法。
- Object.prototype.toString.call(Object); // "[object Function]"

## 关于每个内置对象的 toString 的功能

- Object.prototype.toString => 打印类型， 方法返回一个表示该对象的字符串。
- Function.prototype.toString => `方法返回一个表示当前函数源代码的字符串。`
  - `就是函数本身 ， 可以直接调用`
-

## object

- `create()` `assign()` `defineProperty()` `keys` `value`

- `Object.create(proto[, propertiesObject])` // proto 必须要有的参数， 相当于继承
  - var obj = Object.create({name:'f',age: 15});
  - propertiesObject 相当于属性 描述 (修饰 第一个参数 的属性 (是否可是， ))
  - `value` 初始值
  - `writable` 是否可读写
  - `configurable` 是否可 delete
  - `get` `set` ： Python 的 魔术方法。 自动调用。

```javascript

var obj = { nae:12};
var obj2 = Object.create(obj);
console.log(obj == obj2);
console.log(obj === obj2);

// writable value configurable(与 delete 有关 ,默认是false )) (get set 相当于 python 的魔术方法)  enumerate (是否都可枚举  for(var key in obj){ console.log(key + ":" + obj[key]) })
var test = Object.create(
  {name: '礼拜', age : 20},
  {name:{
    value:'那可丽丽',
    writable: true, // 写入
    configurable: true, // 访问
  },
  age:{
    configurable: false,
    get: function() { return 10 },
    set: function(value) {
      console.log("Setting `o.bar` to", value);
  }}})
console.log(delete test.age); // false , 当 configurable : true 时。 delete 为 false .
//console.log(test)
console.log(test.name, test.age);
console.log(test.name = '我啊', test.name);
console.log(test.age=100, test.age)
name: '礼拜',age: 28
```

- 浅拷贝，且 兼容性不好。
- `var test = Object.assign(target, ...sources)` ; // 改变 target ， 切 test 和 target 的值一样
- 深拷贝, 实例

```javascript
var source = {
  name: "fd",
  age: "fdf",
  obj: {
    oo: "oo",
    arr: ["f", 1, 5]
  }
};
var target = {};
deepcopy(target, source);
function deepcopy(target, source) {
  for (var it in source) {
    if (Object.prototype.toString.call(source[it]) === "[Object Object]") {
      target[it] = {};
      deepcopy(target[it], source[it]);
    } else if (Object.prototype.toString.call(source[it]).includes("Array")) {
      target[it] = [];
      deepcopy(target[it], source[it]);
    } else {
      target[it] = source[it];
    }
  }
}
console.log(target, source);
```

- 将多个 sources 赋值到 target 里。

- `Object.keys(obj)` // 拿到 [] 所有键在数组里面
- `Object.values` // [] 值在 value 里面
- `Object.defineProperty(obj, prop, descriptor)`; // obj 属性对象， property 属性名(string), descriptor 描述
  - descriptor{configurable enumerable value writable get set }
  - configurable

## 类魔术方法

- get
- set
- valueOf( 拿 值是自动调用 )， `str.toString(), str` 都会自动调用 valueOf()

```javascript
function test() {}
test.valueOf = function() {
  return 10;
};
console.log(test + 10); // 当时 test时 为 函数本身。
console.log(test); // 当时 test时 为 函数本身。
```

```javascript
function test(name, age) {
  console.log(name, age, "function test");
}
test.prototype.valueOf = function() {
  console.log(arguments, "arguments", this);
};
console.log(test);
debugger;
test.valueOf(123, "fdfds");
debugger;
```

## 高阶函数

```javascript
function map(arr, callback){
  var newarr = undefined;
  if(arr&& Object.prototype.toString.call(arr) === '[object Array]'){
    newarr= [];
    for( var index in arr){
      newarr.push(arr[index])
    }
    for(var i=0; i< newarr.length; i++){
      newarr[i] = callback(newarr[i],i , arr);
    }
  }else{
    console.error(`arr is a not Array`);
  }
  return newarr;

}
var arr = [1,2,3,4,5];
console.log(map(arr, function(item, index){
  if(item %2 ===0){
    item = item*5;
  }
  return item;
}))


```

## arguments.cellee
- 函数自己，本身


## 作用域链 [[Scope]] 和 [[FunctionLocation]] 仅供 js引擎使用
[关于[[Scope]]](https://blog.csdn.net/q1056843325/article/details/53086893?locationNum=12&fps=1)
[[Scope]]和执行期上下文虽然保存的都是作用域链，但不是同一个东西， **函数在声明定义是就产生了**
现在先明确一点区别
[[Scope]]属性是函数创建时产生的，会一直存在
而执行上下文在函数执行时产生，函数执行结束便会销毁   **函数在执行调用时才有上下文环境**


foo函数执行前，创建了执行期上下文（我暂且把执行期上下文写作EC，内部叫什么名我也不知道），
执行期上下文取得foo内部[[Scope]]属性保存的作用域链（复制），
然后foo函数执行前预编译产生了一个活动对象AO（Active Object），这个对象被推入EC作用域链的最前端

[[FunctionLocation]] : 主要是定位 该函数的代码位置。


## 回调地狱 的解决方法

<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"> promise MDN</a>
- `promise` 许诺 
  - 属性 ： Promise.length , Promise.prototype
  - 方法 : Promise.reject( reason ) , Promise.resolve( value )
    - `reject` 和 `resolve` 用来改变状态的。调用则改变。
  - `Promise.prototype.then()` `Promise.prototype.catch() ` 
  - `then() 两` `catch() 拒绝` `finally() 用try finally理解`
- `async`  `await`
 
```javascript

// promise 构造函数接受一个回调函数， 这个回调函数有两个参数

var promisel = new promise( function (resolve, reject){} )

promisel.then(function (value){

});

```
<div style="color:purple;font-weigth:bold">
<span style="font-size:20px;color:green;">syntax :  var promisel = new promise( executor() );</span><br>
executor是带有 resolve 和 reject 两个参数的函数 。Promise构造函数执行时<span style="color:red;">立即调用executor 函数，</span> resolve 和 reject 两个函数作为参数传递给executor（executor 函数在Promise构造函数返回所建promise实例对象前被调用）。resolve 和 reject 函数被调用时，分别将promise的状态改为fulfilled（完成）或rejected（失败）。executor 内部通常会执行一些异步操作，一旦异步操作执行完毕(可能成功/失败)，要么调用resolve函数来将promise状态改成fulfilled，要么调用reject 函数将promise的状态改为rejected。如果在executor函数中抛出一个错误，那么该promise 状态为rejected。executor函数的返回值被忽略。
</div>

状态
- `pending` : 等待
- `fulfilled` : 成功 是 调用 resolve 则成功；
- `rejected` : 失败 


模拟封装
```javascript

function Promise(callbock){
  this.status = 'pending';
  this.param = undefined;
  this._resolve = Promise.resolve;


  callbock(Promise.resolve.bind(this), Promise.reject.bind(this));

}
Promise.resolve = function (param){
    var that = this;
    setTimeOut(function(){
      that.status = 'fulfilled';
      that.param = param;
        return new Promise()
    },0)
    
  }
Promise.reject = fucntion(param){
    var  that = this;
    setTimeOut(function(){
      that.status = 'rejected';
      that.param = param;
      return new Promise()
    },0)
    
  }

Promise.prototype.then = function(callback){

  var that = callback;
  setTimeout(function(){
    callback(that.param)
  },0)

}
```
## 遮罩原理
- 用一个 div 覆盖原来的页面， 就其他的事件不能 发生了。
- 一般用在做登录页面上。 用一个遮罩覆盖原来页面，加个透明度。

## 获取标签样式
- getComputeStyle 高 ---- currentStyle 低 
- style

## 动画， 定时器等 需要过程的 过程等 可以 `加锁`
旋转木马地址  : https://www.17sucai.com/pins/demo-show?id=34111
https://www.17sucai.com/pins/tag/5539.html
ctrl + w  关闭一个当前网页。


## 
面试题 ： 
函数的节流和防抖
    持续的事件 -》 会造成 多余的事件触发， 造成高频事件， 影响性能。

- **防抖** : 持续事件 保证只触发一次




## 防抖- 高阶函数。 
> 将要执行的事件体函数以回调函数 cb 方式传入
> 然后用 setTimeout 顶一个时间， 保证 高频事件 至少能触发一次
> 关键是在 ： 利用 闭包中 , timeOut 是 同一个变量 。 clearTimeout() 先清， 后再设置 定时器， 比清多一次。 故能调用一次。
```javascript
document.onmousemove = (function (cb){
    var timeOut= null;
    var self = this;
    return function (e){  // 此函数才是 onmousemove 要调用的函数。
        clearTimeout(timeOut);
        var timeOut = setTimeout(function(){
            cb.call(self,e);
            cb.apply(self,[e])
        }，300)
    }
})(cb);

function cb(e){  // 此函是要 实现功能的。
    console.log(e)
} 
```

## 节流 : 只是限制执行次数
在高频事件中 ： 一开始就触发，每隔 300ms 就执行一次。

```javascript

document.onmousemove = (function(cb){
    var timeOut = null;
    var onOff = true;
    return function (e){
        if(!timeOut) return;
        onOff = false;
        // if(onOff){
        //     clearTimeout(timeOut);
        // }
        timeOut = setTimeout(function (){
            onOff = true;
            cb.call(self, e);
        },300)
    }
}(cb))
function cb(e){}
```

## 观察者模式
> 解耦合
发布者 ( publish ) : 发布消息(只有订阅了的才能接受消息)
订阅者 ( subscribe ) : 接受消息

监听过程 -> 订阅: 
执行过程 -> 发布: 

## cdn  网络内容分发系统 ( content delivery network ) 分布式服务器
一般不变的静态资源 - > 资源在离近的地方获取
```javascript
<script src="http://libs.baidu.com/highcharts/2.2.5/highcharts.js"></script>  
```

箭头函数
回调函数传参 setTimeout(function(){ this.jj },0);
箭头函数 : setTimeout(()=>{ this.jj },0) ; 
箭头函数的 this 的继承 ； 继承于 定义于的 父级函数作用域。  
箭头函数 ： 在定义时， 可见的this 指向谁， 调动时 的this 就是谁。

fdsfdsfdsfdsfdsf 我的 

## 移动端的事件

- `touch`  `touchstart` `touchmove`  `touchend`

## this 的复习
> this  是 必须要在函数内才有意义

1) this 是什么
    this 是 知道函数是谁调用的函数
2）为什么要用 this
	不是到函数是谁调用的
3） 要怎么用 ， 有什么问题

this 指向调用者, this必须是用在函数内才有意义。

this的 特殊性。 
	1) 有 call 和 apply， bind
	2) 箭头函数, 是继承 this 的。
	3) 有 new

github ： 
	https://github.com/Tnfe/TNFE-Weekly  js 微信小程序的小项目。
	https://github.com/sunhaoxiang/js-practice 

## 严格模式
在严格模式下 ： this 是不能指向 window 的。

## js 的作用域链
js  是静态作用域 (词法作用域)

undefined + 100 // NaN
null + 100   // 100

undefined 在字符串环境下是："undefined"

　　　　　 在数字环境下是：NaN

　　　　　 在布尔环境下是：false

　　　　　 在对象环境下是：Error

null 在字符串环境下是："null"

    在数字环境下是:0

　　 在布尔环境下是：false

　　 在对象环境下是：Error

## 预解析
变量提升 ： 
	程序运行前， 会把函数声明提示到本作用域的顶端。 
	声明 与 赋值。 

## 深拷贝的另一中思路
1) 先把对象转化为 字符串  str
2) 再有字符串转化为 对象。 obj 

### 拿到对象 的键， 值
for(  i in {name : 'name'} ){
   i 是个 键
}
for( (item, i ) in { name : 'name' } ){
   item 是个键
   i  是个值
}

## Symbol.iterator 迭代器

```js
let itenn = {
	"0" : '这里是可以接受可跌倒的变量',
	"1" : "2 这个是个实验",
	length: 2,
	[Symbol.iterator] : function(){
		var self = this;
		var i = 0;
		return {
			next(){
				var done = ( i >= self.length );
				var value = !done ? self[i++] : undefined;
				return {
					done: done,
					value: value
				}
			}
		}
	}
} 
Object.defineProperty(itenn, 'length', {
	enumerable : false
})
```
这反回的就是一个迭代器了。 可以被 react 的 { itenn } 表达式解析了。 


console.log(obj1 [, obj2, ..., objN);
console.log(msg [, subst1, ..., substN);
console.log(`temp的值为: ${temp}`)
console.log('String: %s, Int: %d,Float: %f, Object: %o', str, ints, floats, obj)
`%c` : 是可以带样式的。 


https://juejin.im/entry/58bb664bac502e006bfeb6d8  隐式转换的链接；
http://yanhaijing.com/es5/#155                    es5 规范的链接
https://juejin.im/entry/58bb664bac502e006bfeb6d8
https://juejin.im/entry/5bc9aae56fb9a05d20687bf3
https://juejin.im/post/5dac5d82e51d45249850cd20  
https://juejin.im/entry/589575478d6d810058381cf1  css演示