## 对象的封装原则(思维)

- 单一原则， 每个对象只做与自己有关的事情， 不要想着跨域。
- 高阶函数，高阶对象。
- 因为作用域的原因， 对象应该封装在 匿名函数里面 function(){return claa}; `鲁棒原则`
- 基于`鲁棒原则` 每个对象单独使用一个 js 文件封装出去。
- js 的文件名就用其内部封装的 class 对象名来表达则可。
-

## 异常捕获

> try throw(抛) catch finally 最终(finally (return 也最终都会执行))
> raise throw(抛)

```javascript
try {
  // 主要代码块
  console.log(a)
  // throw(ReferenceError);
} catch (error) {
  // try 出现 bug 将停止执行，跳到catch
  // error(参数变量) 异常类型
  console.error(error, error.message)
} finally {
} // finally (try里有 return 也会执行)最终都会执行。
// return 应该放在 finally 里。 因为 无论在 try 和 catch 里的return都会 被覆盖。
```

- 捕捉和处理异常
- 用来处理闭包

```javascript
function test() {
  var num = 1
  return function() {
    try {
      throw 'lailai'
      return num
    } catch (error) {
      // 传进来的 error 是一个 对象。
      console.log(typeof error, error) //string lailai
      console.error(error)
    } finally {
      num = undefined // 此时num 以经拿到了， 但是此放回的函数只能 调用一次。
    }
  }
}
let te = test()
console.log(te(), 'ff')
console.log(te(), 'aa')
```

## 正则表达式 regular expression

[github 别人的用法](https://github.com/smileyby/zhengze#js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%80%BB%E7%BB%93)

- 按位对应。

- 特殊字符范围: `\x21-\x2f\x3a-\x40\x5b-\x60\x7B-\x7F`;
- 中文字符范围 : `\u4e00-\u9fa5`;

- `\d`: `digit` 数字 \D 非数字
- `\w`: `word` 单词 (字母，数字，下划线) \W 非单词
- `\r`: `return` 回车
- `\n`： `newline` 换行
- `\s`: `space` 空间，空白
- `\t`: `table` 制表符
- `\v`: `vertical` 垂直
- `\b` : Boundaries
- `\0` : `null`

- 模式 (全局 || 一个)
  ( 元表示单一字符。 )
- 元字符 : `.` `[abcd],[a-z] (代表一个字符)` `\d | \D` `\w` `^ (首位， 非)`
- 限定符 : (限定长度， 模式)
  - `[a]{n} a连续n次` `一定要够n 个`
  - `{n,} 至少n次`
  - `{n,m}` 闭合的范围[] ，n > .<M 都可以。
  - `* {0,}` `+ {1,}` `? {0,1}` `*？贪婪` `+? 非贪婪`
  - `^ 开头`
  - `$ 结尾`
  - `^$ 严格一点`
  - `|` `或`
- `() 优先， 分组`
  - 捕获型 () , 只有() 才参与捕获, 分组值 由 `$1, $2...` 获取
    - `\1` `()\1重复一次(配合 + 使用) 括号内的匹配` `(\d)\1+` `'$1'`重复多次
    - `\2` `(1)(2)\2`
    - () 自动命名组 用 `$digit` 来取
    - (?'name') `自己命名组名字为 name`
  - 非捕获型 (?:)
  - 正向前瞻型 x(?=exp) Lookahead assertion:
    - 断言相当于判断。 本应 x(?=..) x(忽略) (?=..) 就只是判断。
  - 反向前瞻型 (?!exp)x Negative lookahead assertion
  - 后瞻断言 (?<=) Lookbehind assertion
  - 反向后瞻断言 (?<!) Negative lookbehind assertion
    > 我们使用的比较多的都是()捕获型分组，只有这种分组才会暂存匹配到的串, 其他的断言只是辅助断言。

* ## 断言 ： Assertions ()
* 边界 : Boundaries
* 字符类型 : Character Classes
* 组合范围
* 量词
* Unicode 属性转义

#### 断言万能公式

- (?=.\*...) ...(这三个点 要啥给啥)

### 声明方式

```javascript
// RegExp(param1, param2) ; p1正则表达式, p2 匹配规则
//new RegExp(pattern, attributes); // pattern (str),
// attributes  "g" global、"i" ignoreCase  和 "m" multiply | multiple，分别用于指定全局匹配、区分大小写的匹配和多行匹配。
var regex = new RegExp('ab+c'); ==> var regex = /ab+c/;
```

### 方法

- `test` `exec` `match` `matchAll` `search` `replace` `split`
- `regex.test(str)`; // 验证 true false 。str `要比较的的str` `是否符合`
- `regex.exec(str)` `execute 执行`; //

## 电话号码

`^(\+86)?13\d{9}$`

## 邮箱

^\d{5,11}@qq.com\$|

-

^[a-zA-Z0-9\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_-]+@[a-zA-Z0-9\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_-]+(\.[a-zA-Z0-9\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_-]+)+\$

## 字符串 API

- `charAt() == [index]` `concat()` `indexOf()`
- `charAt(index)=> 字符值`
- `+` 每次+ 完都会在内存里遗留上一次+ 完的字符串
- `str.concat(strli)` 效率高点 字符串相加
- `str.indexOf(searchString,position) => n(第一个出现的位置) 或 -1`
- `str.lastIndexOf() 最后出现的位置`
- `str.match(str1)`
- `str.repace()`
- `search()`
- `slice(start,end)` `substr(start,length)` `substring(start, end) 不包含end`
- `trim()` `trimStart()` `trimEnd()`

```javascript
var str = '今天天气不错，xiaomin起床后，洗漱来上课，xiaomin匆匆忙忙挤入地道，在繁忙的人群中开始一天新的生活，终于到达了公司楼下，xiaomin淡定的在楼下点了根烟，看看时间，还够，最后上楼，xiaomin木有迟到，真好！'

var str1 = 'xiaomin';
var num = 7;
var str2 = '';
var count=0;
for(var i=0; i< str.length; i++){
  str2 = str.indexOf(str1);
  for(var j=0; j.. ;j++)

}

```

## 文章

[nodejs](https://github.com/jimuyouyou/node-interview-questions)

## for in of

for in

> 以任意顺序遍历一个对象自有的、(继承的)、可枚举的、非 Symbol 的属性。对于每个不同的属性，语句都会被执行。
> for of
> 在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句

## new 的坑。

1） 优先级
2） 构造函数里面的 return obj ; 返回一个对象会 覆盖原来的 this

```javascript
var obj = { grad: 'ha' }
function func1(obj) {
  this.name = 'na'
  this.age = 20
  return obj
}
var f1 = new func1(obj)
console.log(f1) //=>  obj
```

## Array

- arr.concat(arr1,arr2，arr3); // 拼接数组，成一维数组
- arr.join([separator]); // separator 分割符 =》 字符串
- arr.shift(); //从数组中删除第一个元素，并返回该元素的值。 更改原函数
  - return 当一个对象调用该方法时，返回其 length 属性值。
- arr.unshift(element1...); // 首位添加， => length
- arr.push(elemts); // 尾部追加。 => length
- arr.slice(begin[,end]); // return newArray
- arr.splice(start[,deleteCount],[,item,..]); //用 item 替换多少个 deleteCount
- arr.pop(); 弹出， 修改原函数

## delete

> delete 操作符与直接释放内存无关。内存管理 通过断开引用来间接完成的
> 操作符用于删除对象的某个属性；如果没有指向这个属性的引用，那它最终会被释放。
> 只是个值给删除了， 数组长度没变
> return true; 基本是 放回 true, 只有在严格模式下 c 才有可能返回 false
> 除了在全局作用域中的函数不能被删除，在对象(object)中的函数是能够用 delete 操作删除的。

- 可以直接 删除 对象属性。
- delete expression

```javascript
// 模拟 pop
Array.prototype.mypop = function() {
  var end = this[this.length - 1]
  delete this[this.length - 1]
  this.length = this.length - 1
  return end
}
```

## length -1 ; 原来的值还会在 内存中

## Date 对象

- `new Date();` // Mon Sep 23 2019 12:04:23 GMT+0800 (中国标准时间)
- `new Date(value);` // (2000-09-05 00:21:00:000)
- `new Date(dateString);` // (1990-09-05 00:21:00:000)
- `new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]]);`

- `year` `month` `day` `hour` `minute` `seconds`
- return 的 格林威治日期格式

- 2019-09-23 11:59:00;

方法 `getFullYear` `getdate(月份的 第几天)` `getday 星期第几天` `getHours()` `getMinutes()` `getMillisecondes() 0-999`

- new Date().getFullYear() ; // number
- new Date().getMonth(); // 老外是 从 0 (12)开始计算的。
- new Date().getdate(); // 月第几天
- new Date().getday(); // 星期 n 天

### 时间戳

> 时间戳:是指格林威治时间 1970 年 01 月 01 日 00 时 00 分 00 秒(北京时间 1970 年 01 月 01 日 08 时 00 分 00 秒)起至现在的总秒数。

- 1 秒 == 1000 毫秒
- 1 秒=1000 毫秒(ms), 1 毫秒=1／1000 秒(s)；
- 1 秒=1000000 微秒(μs), 1 微秒=1／1000000 秒(s)；
- 1 秒=1000000000 纳秒(ns),1 纳秒=1／1000000000 秒(s)；
- 1 秒=1000000000000 皮秒 1 皮秒==1/1000000000000 秒。

固定时间内-删除内存(过期内容)

## 类型检测

- 检测数组 Array.isArray( value ); // true， false
- typeOf
- instanceof
- Object.prototype.toString.call()
  - Object.prototype.toString.call(f).includes('Number')
  - `Object.protoptype.toString 可以获取类型的字符串值。`
  - `call 改变 toString 的this指向。`
  - Number.prototype.toString 已经覆盖了 Object.prototype.toString 的方法。
  - 基本上， 每个类型 都已经重写了 toString 方法。
- Object.prototype.toString.call(Object); // "[object Function]"

## 关于每个内置对象的 toString 的功能

- Object.prototype.toString => 打印类型， 方法返回一个表示该对象的字符串。
- Function.prototype.toString => `方法返回一个表示当前函数源代码的字符串。`
  - `就是函数本身 ， 可以直接调用`
-

## object

- `create()` `assign()` `defineProperty()` `keys` `value`

- `Object.create(proto[, propertiesObject])` // proto 必须要有的参数， 相当于继承
  - var obj = Object.create({name:'f',age: 15});
  - propertiesObject 相当于属性 描述 (修饰 第一个参数 的属性 (是否可是， ))

```javascript

var obj = { nae:12};
var obj2 = Object.create(obj);
console.log(obj == obj2);
console.log(obj === obj2);

// writable value configurable(与 delete 有关 )) (get set 相当于 python 的魔术方法)  enumerate
var test = Object.create(
  {name: '礼拜', age : 20},
  {name:{
    value:'那可丽丽',
    writable: true, // 写入
    configurable: true, // 访问
  },
  age:{
    configurable: false,
    get: function() { return 10 },
    set: function(value) {
      console.log("Setting `o.bar` to", value);
  }}})
console.log(delete test.age); // false , 当 configurable : true 时。 delete 为 false .
//console.log(test)
console.log(test.name, test.age);
console.log(test.name = '我啊', test.name);
console.log(test.age=100, test.age)
name: '礼拜',age: 28
```

- 浅拷贝，且 兼容性不好。
- `var test = Object.assign(target, ...sources)` ; // 改变 target ， 切 test 和 target 的值一样
- 深拷贝, 实例

```javascript
var source = {
  name: 'fd',
  age: 'fdf',
  obj: {
    oo: 'oo',
    arr: ['f', 1, 5]
  }
}
var target = {}
deepcopy(target, source)
function deepcopy(target, source) {
  for (var it in source) {
    if (Object.prototype.toString.call(source[it]) === '[Object Object]') {
      target[it] = {}
      deepcopy(target[it], source[it])
    } else if (Object.prototype.toString.call(source[it]).includes('Array')) {
      target[it] = []
      deepcopy(target[it], source[it])
    } else {
      target[it] = source[it]
    }
  }
}
console.log(target, source)
```

- 将多个 sources 赋值到 target 里。

- `Object.keys(obj)` // 拿到 [] 所有键在数组里面
- `Object.values` // [] 值在 value 里面
- `Object.defineProperty(obj, prop, descriptor)`; // obj 属性对象， property 属性名(string), descriptor 描述
  - descriptor{configurable enumerable value writable get set }
  - configurable
