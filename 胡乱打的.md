

node  节点： 

1 element
2 attribute
3 text
4 cdata_section

8 comment
9 document


node  
属性： 
    baseURI : 一般以文档的 uri 一样
    childNodes :  子节点。 
    firstChild  : 第一个子节点
    isConnected  : 是否连接。  是否与 Document 对象连接  可用于虚拟节点的判断
    lastChild : 最后一个子节点
    nextSibling  : 下一个兄弟节点
    ownerDocument :  顶层的Document
    parentNode : 
    parenElement :
    previousSibling : 


    nodeName 
    nodeType
    nodeValue : 属性, 文本, 



    拦截器 ： 
        axios.interceptors.request.use  请求拦截
            主意点是 要return config  相当于毛坯
            err   return Promise.reject( error )
        axios.interceptors.response.use  响应拦截

## package.json 的配置的选项抄集
- Description 

- name
- version
- description
- keywords
- homeage
- bugs
- license
- author, contributors
- files
- main
- browser
- bin
- man
- directories
- repository   create a new repository 创建一个新的仓库
- scripts
- config
- dependencies
- urls as Dependencies
- git urls as dependencies
- local paths
- devDependencies
- peerDependencies
- bundledDependencies
- optionalDependencies
- engines
- enginesStrict 
- private
- Default values


Event : 
    bubbles      是否可以冒泡
    cancelable   可以被取消 默认行为
    cancelBuble   
    composed   scoped
    currentTarget   -->  target
    defaultPrevented
    eventPhase
    srcElement
    target
    timeStamp
    type




store = Redux.createStore( fn );   创建 仓库
fn(state, actions){

}

store.getState();
store.dispatch();


redux 是第三方的 状态管理器。 
默认是不会 数据变化到至 视图的变化。 

store.subscribe();  是一个检测数据变化的函数。 当 state 变化是触发。 
store.combineReducer();  合并 把 fn 传入进来。 

state 数据修改的方式 是每次都是同一个地址还是 用一个深拷贝覆盖他呢？？？ 




```js

Promise.all([]);  // 与操作， 全真的得真
Promise.rece([]);  // 类似或操作， 只要有一个状态改变了就 调用 then的回调。
Promise.finally(); 

```

---------------------------------------  React + Redux 结合体。 

1.  利用 props 来作响应。  那就需要在根组件中 把 props 需要的数据传下来。 


```js
function num (state=10, actions){
    return state
}
let reduce = Redux.combineReducers({num});
let store = Redux.createState( reduce );

// 或去数据
function stateTopProps( state, parentProps ){
    // 把 state 的num 赋值给了 props.num ; 
    return {
        num : store.getState().num
    }
}

// 修改数据。 
function dispatchToProps(dispatch, parentProps){
    // dispatch 就是  store.dispatch . 
    // parentProps 
    return {
        add(){
            dispatch({ type : "ADD" })
        },
        reuce(){
             dispatch({ type : "ADD" })
        }
    }
}

// 挂钩关系 , 函数的柯里化。 就是高阶函数 。  Box1 是 子组件的变量。 
// 相当于 把 子组件预编译。 
let NewBox1 = ReactRedux.connect( stateToProps, dispatchToProps )(Box1)

class Root extends React.Component {


    render(){
        return (
            <ReactRedux.Provider store = {store} >
                <NewBox1 />
            </ReactRedux.Provider>
        )
    }
}



```
<!-- provide ： 提供。  -->

react 的路由

```js

let { HashRouter : Router, Route, Redirect, Link, NavLink, Switch} = ReactRouterDOM; 
// 从路由中导入,  hash 值    重定向
// 这三个都是组件. 的形式 -> 组件就是直接卸载 render 中的。 
// Router ->  路由的所有的组件都必须包裹在 Router 内
// Route  ->  路由选项
    // path="/home" component={} render(){}
//    <Route path="/home" component={} 或 render(){} >
// Redirect ->  路由重定向。 
//  Link  跳转组件。 -> a 
// NavLink  导航link 
//      activeClassName 是 NavLink 的切换视图时 的按钮样式。 
// Switch  是路由切换的顺序。 当第一个 路由匹配是就停止后面的匹配
//    <Route path="/home" component={Home} >
//    <Route path="/home" component={News} >

//  Switch 就会停止匹配到 第二个。 只有一个生效的。 

// 嵌套路由 。 什么是嵌套路由？？？ 就是由二级路由。 

// ----------------------------------------------
//     vue 写法 
//  route : [ { path : "/home", component : {home} , children : [{ path : "/home/product"... }] } ]


class Home extends React.Component{

    render(){
        <div>
            <h3>新闻</h3>
            <p>这一页内容</p>
        </div>
    }
}
class News extends React.Component{

    render(){
        <div>
            <h3>新闻</h3>
            <p>这一页内容</p>
        </div>
    }
}
class Product extends React.Component{

    render(){
        <div>
            <h3>新闻</h3>
            <p>这一页内容</p>
        </div>
    }
}

class RouterView extends React.Compoent{
    render(){
        return (
            <Router>
                <div>
                    <NavLink to></NavLink>

                    <Switch>
                        <Route path="/home" component={Home} />
                        <Route path="/news" component={News} />
                        <Route path="/product" component={product} />
                        <Redirect path="/" to={Home} >
                    </Switch>
                </div>
            </Route>
        )
    }
}

class Root extends React.Component{
    render(){
        return (
            <div>
                <RouterView />>
            </div>
        )
    }
}

ReactDOM.render(<Root />, document.getElementById('root'))

```




