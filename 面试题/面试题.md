/_面试题：有下边的一个方法的调用
add(1)(2,3)(1,2,3,4)(5,7)
已知：add 是一个函数，可以随意无限进行柯里化调用，每次调用时，传递的参数都是 number 数字，
不确定传了几个参数，那么在什么时候不想继续调用时，请输出上边表达式里所有参数的和！
请说出你的封装思路，和封装代码，这是一道经典的算法题
_/

```javascript


function add()
    var args = arguments;
    function _fun(){

        return add;
    }
    return _func();




        // 提示：关键思路，所有参数的和，用valueOf来统计，也就是说，上边表达式在调用到最后不想调用时
        // add(1)(2,3)(1,2,3,4)(5,7).valueOf()，直接拿到结果值，所有参数的和
        console.log(add(1, 6, 7)(2, 3)(1, 2, 3, 4)(5, 7).valueOf());
        function add() {
            // 第一次调用add时，add里的arguments[0]是一个数字Number！
            // 后边再次调用add方法时，arguments[0]就变成了addArguments一个数组Array！
            var addArguments = Object.prototype.toString.call(arguments[0]) === '[object Array]'
                ? arguments[0] : Array.from(arguments);
            function func() {
                // 哪层方法的arguments，就是哪层方法函数自己的，跟别的函数无关，无作用域传递，毕竟是
                // 函数三要素之一，函数自己的货
                for (var index in arguments) {
                    addArguments.push(arguments[index]);
                }
                return add(addArguments);
            }
            // 重写func方法的valueOf方法，在这个里边计算数组里所有参数的和
            func.valueOf = function () {
                var sum = 0;
                for (var index in addArguments) {
                    sum += addArguments[index];
                }
                return sum;
            }
```

### 作用域问题

```javascript
function func1(o, n) {
  console.log(n);
  return {
    func1: function(m) {
      return func1(m, o);
    }
  };
}
func1(0)
  .func1(1)
  .func1(2)
  .func1(3); // 输出结果是？

var test = {
  func1: function() {
    console.log(func1, test);
  }
};
test.func1(); // func1 (func1 is a not defined)是一个键， 需要对象. 才能获得。 test可以输出。
```

### 底层 valueOf toString

- 当有隐式转换趋向时， 会调用底层的 toString 和 valueOf 方法， 这些方法可以重写。

> if(a ===1 && a === 2 && a === 3){console.log('呵呵')}

```javascript
var a = {
  value: 0,
  valueOf: function() {
    return this.value;
  }
};
var a = new Number(0);
a.value = 0;
Number.prototype.valueOf = function() {
  return ++this.value;
};
// console.log(a++,++a)
if (a == 1 && a == 2 && a == 3) {
  console.log("呵呵");
}
console.log(a++);
console.log(a === 2);
```

### 数组去重的解决

`有这样的 [1,1,2,2,1,2,1,2,13,3,8,7,5], 对上边数组去重，`
`并统计每个数据出现的次数`

> 思路是 ： 创建对象， 利用用键的不可重复性， 不断检索添加，修改

```javascript
var arr = [1, 1, 2, 2, 1, 2, 1, 2, 13, 3, 8, 7, 5];
var obj = {};

for (var index in arr) {
  if (obj[arr[index]]) {
    obj[arr[index]]++;
  } else {
    obj[arr[index]] = 1;
  }
}
var newArr = [];
for (var num in obj) {
  newArr.push(num);
}

console.log(obj, newArr);
```

### 字符串拼接

> 需求： 格式化字符串方法,
> formaString('今天天气不错， {1}带着耳机，{2}地迈着脚步', '小明','开心的');

- 当不知道 回调函数的参数是， 最好的方式就是输出以下。

```javascript
function formatString(metastr, rep1, rep2) {
  var _arguments = arguments;
  var conut = 0;
  // 匹配的结果， 用 function 的返回值来替换 正则匹配到的值。
  var newstr = _arguments[0].replace(/\{\d+\}/g, function(
    matchValue,
    matchIndex,
    oldStr
  ) {
    console.log(arguments, matchValue, matchIndex, oldStr);
    conut++;
    return _arguments[conut];
  });
  return newstr;
}
console.log(
  formatString("今天天气不错， {1}带着耳机，{2}地迈着脚步", "小明", "开心的")
);
```
